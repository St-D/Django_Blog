========================================================================================================================
# Django_Blog
blog with comments and registration. The ability to upload user avatars and resize him (RabbitMQ)

###### Version
_import django
django.get_version()
'1.11.3'_

### Installation
Install the package:
$ pip install celery

https://www.rabbitmq.com/download.html
http://www.erlang.org/downloads

run rebbitMQ:
  rabbitmq-service
  rabbitmq-plugins enable rabbitmq_management
  http://localhost:15672/#/   (user: guest, password: guest)

run and show Queue:
celery -A blog_project worker --pool=solo -l info
========================================================================================================================
####	- Общее описание -
-Для беглого ознакомления без развертывания, можно просмотреть в папке PrintScrn скрины с некоторых страниц сайта.
-Также в корне находится ERM-диаграмма.
-В blog_app\migrations\*.sql содержится дамп рабочей базы включающей в себя:
	4-х зарегистрированных пользователей (хэш всех пользователей соответствует паролю 1111qqqq, также указан email при регистрации и настроен на вывод в консоль при утере пароля),
	аватарки,
	их статьи и комментарии,
	комментарии к комментариям,
	подписки пользователей друг на друга.
	Пользователя admin (хэш соответствует паролю adminadmin, email также указан)
- В качестве DB при разработке использовалась MySQL. При использовании другой DB нужно сменить настройки.
- JS на страницах не используется , за исключением страницы со статьей и комментариям к ней.


- главная страница различается для авторизованного пользователя и для гостя сайта:
	* изменены ссылки NavBar
	* для гостя лента новостей выглядит как 10 случайных статей случайных пользователей
	* для пользователя в ленте отображаются 10 случайных статей случайных пользователей, кроме собственных статей пользователя.
	* изображение в левой части сайта всегда случайное.

- страницы авторизации/регистрации содержат ссылки друг на друга и на сброс пароля через email.
	* при регистрации необходимо добавить изображение для аватарки.

- подписки пользователя <Favorites> содержат информацию о пользователях добавленных в подписку, а также информацию о том, как давно был
пользователь зарегистрирован на сайте.
	* подписаться на пользователя можно, например, кликнув на главной странице по аватврке пользователя. Откроется страница со всеми статьями
пользователя, в самом низу будет ссылка <Add to MyFavorites> позволяющай добавить пользователя в список понравившихся. при клике
на эту ссылку рядом появится flash сообщение о статусе операции.

- <MyPost> содержит все опубликованные статьи пользователя.

- для просмотра статьи и комментариев к ней нужно кликнуть на тему статьи.
	* можно добавить комментарий к статьей
	* можно добавить комментарии к комментарию любой вложенности,
	* форма комментария появится автоматически.


- <New Post> страница с формой для добавления новой статьи.
========================================================================================================================
####	- Подробное описание -
#####   Описание схемы базы данных (откройте файл ERM.png)
========================================================================================================================
	- Как устроены комментарии.
##### Модель Comment.
	######- Свойства:
	*content - содержание комментария,
	*article - внешний ключ на одноименную модель,
	*create - дата создания (автозаполнение),
	*who_comment - внешний ключ на модель User (django.contrib.auth.models), несет информацию о пользователе, оставившем комментарий,
	*reply_to_comment - внешний ключ модели на саму себя по полю id. Если комментарии оставлен к статье, то поле не заполняется (null),
		если комментарии оставлен к комментарию (максимальная вложенность ограничена стеком рекурсии), то в это поле вносится id
		родительского комментария.
			Таким образом, систему ответов на комментарии можно рассматривать как граф.
			Так, например (см. дамп), для статьи с id=1, имеются комментарии с id = (1, 2, 3, 4). У этих комментариев свойство reply_to_comment - null,
			- это комментарии непосредственно к статье.
			Также у статьи имеются комментарии с id = (17, 18, 19, 20, 21, 54, 55, 56, 57) c непустым свойством reply_to_comment - это комментарии к
			комментариям.
			Рассмотрим граф (лес), у которого кол-во компонентов связности равно кол-ву комментариев к статье(деревья). Граф задан списком ребер:
			[(1, 17), (2, 18), (2, 19), (2, 20), (20, 21), (21, 56), (18, 54), (54, 55), (56, 57),]  # 3 и 4 - явные комментарии к статье, в расчет не берем.

			1			 2				3		4
			|			/|\				|		|
			17		  18 19 20			null	null
					 /		 \
					54		 21
					|			\
					55			56
								|
								57
			Получается, что список узлов для:
			* корня 1 - [17]
			* корня 2 - [18, 54, 55, 19, 20, 21, 56, 57]
			Вычисление списка узлов-потомков осуществляется при передаче параметров (id_статьи, id_not_null_комментария) через пользовательский шаблонный фильтр.

	######- Пользовательские свойства:
	*is_comment - возвращает TRUE(reply_to_comment=null)  или FALSE(reply_to_comment!=null) - используется в шаблоне, когда иерархически
		сначала выводятся комментарии к статье, под ними комментарии к комментариям статьи.
	*content_from_parent - только для записей (is_comment == FALSE). При комментарии комментария добавляет в шапку блока комментария
		первые 30 символов (плюс '...') родительского комментария для ясности.

##### Шаблон и контроллер (views).
	######- Отображение комментариев:
	- отправляем в шаблон выборку всех комментариев статьи, для которых (reply_to_comment=null) - это родительские комментарии (корни деревьев,
		о связи теории графов и комментариев - выше).
	- в шаблоне итерируем выборку. Отображаем комментарий выборки, после проверяем есть ли для данного комментария потомки.
		Передаем id_статьи (как переменную) и id_комментрия (итерируемого; как параметр) в пользовательский фильтр
		{id_article|get_discus_for_comment:id_comment}.
		Дальнейшие вычисления проводит функция get_discus_for_comment (templatetags/recursion_of_comments.py).
		Осуществляется классический алгоритм обхода графа в глубину (рекурсивно) по списку ребер.
		Функция возвращает список узлов (комментарии к комментариям), если они имеются. В шаблоне узлы отображаются хронологически.
			Вне зависимости от уровня вложенности, все комментарии к комментариям и дальнейшие их потомки отображаются с одинаковым сдвигом.
			Комментарии, относящиеся именно к статье - отображаются без сдвига.

	######- Добавление комментариев:
	- добавление комментария производится путем заполнения формы и отправки её POST-запросом непосредственно в функцию views.py/article.
		Схема с дополнительной обработкой UrL при этом не производится.
	- форма комментария (include_html/comment_form.html, forms.py/CommentForm) представляет собой поле содержания комментария, а также скрытое поле,
		которое несет в себе id комментария, на который осуществляется ответ (комментарий). Если атрибут value="" данного поя не заполняется,
		то в соответвии с логикой модели - этот комментарий адресован непосредственно к тексту статьи (reply_to_comment=null).
			Атрибут value="" скрытого тэга <input> заполняется функцией JS (jQuery) (show_comments_form; скрипт простой описан инлайн в шаблоне).
		Вызов функции с передачей в нее параметра (id комментария, с последующей передачей в представление) происходит при нажатии на ссылку <Reply> комментария.
		Также эта функция производит отображение формы комментария (ранее скрыта) и плавное премещение к ней при нажатии <Reply>.
========================================================================================================================
